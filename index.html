<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>JumpStick Vertical</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #333;
  overflow: hidden;
}
</style>
</head>
<body>
<div id="game"></div>

<script>
let player;
let platforms;
let cursors;

const TARGET_CUBE_SIZE = 80;   // taille d'un cube
const GAP_CHANCE = 70;         // 70% de chance de générer un cube dans une colonne

let lastRowY;                  // position de la dernière ligne générée

const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: window.innerWidth,
    height: window.innerHeight,
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    backgroundColor: '#999999',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 300 }, debug: false }
    },
    scene: { preload, create, update }
};

new Phaser.Game(config);

/* ================= PRELOAD ================= */
function preload() {
    this.load.spritesheet('perso', 'assets/personnage.png', {
        frameWidth: 320, frameHeight: 480
    });
    this.load.image('cube1', 'assets/cube1.png');
    this.load.image('cube2', 'assets/cube2.png');
    this.load.image('cube3', 'assets/cube3.png');
}

/* ================= CREATE ================= */
function create() {
    platforms = this.physics.add.staticGroup();

    // Générer 10 premières lignes
    lastRowY = this.scale.height;
    for (let i=0; i<10; i++) {
        lastRowY = generateRow(this, lastRowY);
    }

    // Joueur
    player = this.physics.add.sprite(200, this.scale.height - 100, 'perso');
    player.setScale(0.125);
    player.setBounce(0.1);
    player.setCollideWorldBounds(true);
    player.body.setSize(player.width*0.5, player.height*0.8);
    player.body.setOffset(player.width*0.25, player.height*0.2);

    this.physics.add.collider(player, platforms);

    cursors = this.input.keyboard.createCursorKeys();

    // Animations
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('perso', {start:0, end:3}),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'turn',
        frames: [{key:'perso', frame:4}],
        frameRate: 20
    });
    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('perso', {start:5, end:8}),
        frameRate: 10,
        repeat: -1
    });

    // Caméra suit le joueur verticalement
    this.cameras.main.startFollow(player, false, 0, 1);
}

/* ================= UPDATE ================= */
function update() {
    // Déplacements
    if (cursors.left.isDown) {
        player.setVelocityX(-160);
        player.anims.play('left', true);
    } else if (cursors.right.isDown) {
        player.setVelocityX(160);
        player.anims.play('right', true);
    } else {
        player.setVelocityX(0);
        player.anims.play('turn', true);
    }

    // Saut
    if (cursors.up.isDown && player.body.blocked.down) {
        player.setVelocityY(-330);
    }

    // Génération de nouvelles lignes si le joueur monte
    if (player.y < lastRowY + 300) { // +300 pour buffer
        lastRowY = generateRow(this, lastRowY);
    }
}

/* ================= FONCTION GENERATION ================= */
function generateRow(scene, rowY) {
    const cols = Math.floor(scene.scale.width / TARGET_CUBE_SIZE);

    const y = rowY - TARGET_CUBE_SIZE; // position de la nouvelle ligne

    for (let i=0; i<cols; i++) {
        if (Phaser.Math.Between(0, 100) < GAP_CHANCE) {
            const cube = Phaser.Math.Between(1,3);
            const texture = scene.textures.get('cube'+cube).getSourceImage();
            const scale = TARGET_CUBE_SIZE / texture.width;
            const x = i * TARGET_CUBE_SIZE;
            scene.platforms.create(x, y, 'cube'+cube).setScale(scale).refreshBody();
        }
    }
    return y;
}
</script>
</body>
</html>
