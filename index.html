<!doctype html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <title>JumpStick - Climbing Edition</title>
  <link rel="icon" type="image/png" sizes="64x64" href="./favicon.png">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>

  <!-- Boutons en overlay -->
  <img src="assets/logohome.png" style="cursor:pointer;width:80px;position:fixed;top:10px;left:10px;z-index:1000;"
    onclick="window.location.href='./index.html'">

  <img src="assets/logoretour.png" style="cursor:pointer;width:80px;position:fixed;top:10px;left:100px;z-index:1000;"
    onclick="window.location.href='./niv1a10.html'">

  <img src="assets/logorefresh.png" style="cursor:pointer;width:80px;position:fixed;top:10px;right:10px;z-index:1000;"
    onclick="location.reload()">

  <script>
    // ================= CONFIG =================
    const config = {
      type: Phaser.AUTO,
      width: window.innerWidth,
      height: window.innerHeight,
      physics: {
        default: 'arcade',
        arcade: { 
          gravity: { y: 300 }, 
          debug: true 
        }
      },
      scene: { preload, create, update }
    };

    new Phaser.Game(config);

    // ================= VARIABLES =================
    let player, cursors, platforms;
    let gameOver = false;
    let score = 0;
    let scoreText;
    let highestY = 0;
    
    // Pattern de plateformes qui se répète
    const platformPattern = [
      { x: 0.5, y: 0, size: 1.0 },      // Centre, grande
      { x: 0.3, y: 200, size: 0.9 },    // Gauche
      { x: 0.7, y: 400, size: 0.8 },    // Droite
      { x: 0.5, y: 600, size: 0.75 },   // Centre
      { x: 0.2, y: 800, size: 0.7 },    // Gauche
      { x: 0.8, y: 1000, size: 0.65 },  // Droite
      { x: 0.4, y: 1200, size: 0.6 },   // Gauche-centre
      { x: 0.6, y: 1400, size: 0.55 },  // Droite-centre
      { x: 0.5, y: 1600, size: 0.5 },   // Centre
      { x: 0.3, y: 1800, size: 0.45 },  // Gauche
    ];
    
    let platformGroup;
    let currentPatternOffset = 0;

    // ================= PRELOAD =================
    function preload() {
      this.load.image('sky', 'assets/sky.png');
      this.load.image('cube1', 'assets/platform.png');
      this.load.image('cube2', 'assets/platform.png');
      this.load.image('cube3', 'assets/platform.png');

      const selectedChar = localStorage.getItem('selectedCharacter') || '1';
      this.load.spritesheet('dude', `assets/personnageframe${selectedChar}.png`, {
        frameWidth: 320,
        frameHeight: 480
      });
    }

    // ================= CREATE =================
    function create() {
      const width = this.cameras.main.width;
      const height = this.cameras.main.height;

      // Fond qui se répète
      this.add.tileSprite(width / 2, height / 2, width, height * 3, 'sky');

      // Score / Hauteur
      scoreText = this.add.text(width / 2, 30, 'Hauteur: 0m', {
        fontSize: '28px',
        fill: '#fff',
        stroke: '#000',
        strokeThickness: 4
      }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(100);

      // Groupe de plateformes
      platformGroup = this.physics.add.staticGroup();

      // Plateforme de sol complète au départ (toute la largeur)
      const groundPlatform = platformGroup.create(width / 2, height - 20, 'cube1');
      groundPlatform.displayWidth = width;
      groundPlatform.displayHeight = 64;
      groundPlatform.refreshBody();
      groundPlatform.cubeType = 'cube1';

      // Générer les premières plateformes
      generatePlatforms(this, 0, -2000);

      // Joueur
      player = this.physics.add.sprite(width / 2, height - 90, 'dude');
      player.setScale(0.125);
      player.setBounce(0.2);
      player.setCollideWorldBounds(false); // Pas de limites pour pouvoir tomber
      player.body.setSize(player.width * 0.5, player.height * 0.8);
      player.body.setOffset(player.width * 0.25, player.height * 0.2);

      // Animations
      this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
      });

      this.anims.create({
        key: 'turn',
        frames: [{ key: 'dude', frame: 4 }],
        frameRate: 20
      });

      this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
      });

      cursors = this.input.keyboard.createCursorKeys();

      // Collisions
      this.physics.add.collider(player, platformGroup);

      // Caméra suit le joueur verticalement
      this.cameras.main.startFollow(player, false, 0, 0.1);
      this.cameras.main.setDeadzone(0, height * 0.3);
      
      // Limite gauche-droite du monde
      this.physics.world.setBounds(0, -100000, width, 100000);
      player.setCollideWorldBounds(true);

      highestY = player.y;
    }

    // ================= UPDATE =================
    function update() {
      if (gameOver) return;

      // Contrôles
      if (cursors.left.isDown) {
        player.setVelocityX(-250);
        player.anims.play('left', true);
      } else if (cursors.right.isDown) {
        player.setVelocityX(250);
        player.anims.play('right', true);
      } else {
        player.setVelocityX(0);
        player.anims.play('turn');
      }

      // Saut - utiliser blocked.down pour les groupes statiques
      if (cursors.up.isDown && player.body.blocked.down) {
        player.setVelocityY(-330);
      }

      // Mise à jour du score (hauteur)
      if (player.y < highestY) {
        highestY = player.y;
        score = Math.floor((this.cameras.main.height - highestY) / 10);
        scoreText.setText('Hauteur: ' + score + 'm');
      }

      // Générer plus de plateformes quand on monte
      const cameraTop = this.cameras.main.scrollY;
      generatePlatforms(this, cameraTop - 1000, cameraTop - 3000);

      // Mort si on tombe en bas de l'écran (seulement si on descend)
      const cameraBottom = this.cameras.main.scrollY + this.cameras.main.height;
      if (player.y > cameraBottom + 50 && player.body.velocity.y > 0) {
        die(this);
      }

      // Nettoyer les plateformes trop basses
      platformGroup.children.entries.forEach(platform => {
        if (platform.y > cameraBottom + 500) {
          platform.destroy();
        }
      });
    }

    // ================= FONCTIONS =================
    function generatePlatforms(scene, minY, maxY) {
      const width = scene.cameras.main.width;
      const height = scene.cameras.main.height;
      
      // Calculer combien de patterns on doit générer
      const patternHeight = 2000; // Hauteur d'un pattern complet
      const startPattern = Math.floor(maxY / patternHeight);
      const endPattern = Math.floor(minY / patternHeight);
      
      for (let p = startPattern; p <= endPattern; p++) {
        const baseY = p * patternHeight;
        
        platformPattern.forEach(platform => {
          const x = platform.x * width;
          const y = baseY + platform.y;
          
          // Vérifier si une plateforme existe déjà à cet endroit
          const exists = platformGroup.children.entries.some(existing => 
            Math.abs(existing.x - x) < 10 && Math.abs(existing.y - y) < 10
          );
          
          if (!exists && y < minY && y > maxY - 500) {
            const cubeTypes = ['cube1', 'cube2', 'cube3'];
            const cubeType = Phaser.Utils.Array.GetRandom(cubeTypes);
            
            const newPlatform = platformGroup.create(x, y, cubeType);
            newPlatform.setScale(platform.size * 1.5).refreshBody();
            newPlatform.cubeType = cubeType;
          }
        });
      }
    }

    function die(scene) {
      if (gameOver) return;
      
      gameOver = true;
      scene.physics.pause();
      player.setTint(0xff0000);
      player.anims.play('turn');

      const width = scene.cameras.main.width;
      const height = scene.cameras.main.height;

      scene.add.text(width / 2, height / 2, 'Game Over!', {
        fontSize: '64px',
        fill: '#ff0000',
        stroke: '#000',
        strokeThickness: 6
      }).setOrigin(0.5).setScrollFactor(0).setDepth(100);

      scene.add.text(width / 2, height / 2 + 70, 'Hauteur finale: ' + score + 'm', {
        fontSize: '32px',
        fill: '#fff',
        stroke: '#000',
        strokeThickness: 4
      }).setOrigin(0.5).setScrollFactor(0).setDepth(100);

      scene.time.delayedCall(3000, () => {
        window.location.href = 'index.html';
      });
    }

    // Redimensionnement de la fenêtre
    window.addEventListener('resize', () => {
      game.scale.resize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>
</html>
